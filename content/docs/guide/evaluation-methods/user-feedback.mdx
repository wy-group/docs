---
title: 用户反馈
description: 设计和实施有效的用户反馈收集系统，获取真实世界的评估数据
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# 用户反馈系统

用户反馈是最真实的评估数据来源，直接反映了产品在实际使用中的表现。本章将介绍如何设计、实施和分析用户反馈系统。

## 用户反馈的价值

### 为什么用户反馈至关重要

<Mermaid
  chart="
graph TD
    A[用户反馈价值] --> B[真实场景]
    A --> C[持续改进]
    A --> D[业务指标]
    A --> E[问题发现]
    
    B --> B1[实际使用模式]
    B --> B2[边缘案例]
    
    C --> C1[产品迭代]
    C --> C2[模型优化]
    
    D --> D1[用户满意度]
    D --> D2[留存率]
    
    E --> E1[未预期行为]
    E --> E2[新需求]
"
/>

<Callout type="info">
**数据显示**：根据研究，基于用户反馈优化的模型，用户满意度平均提升 35%。
</Callout>

## 反馈类型设计

### 反馈机制分类

<Tabs items={['显式反馈', '隐式反馈', '主动反馈', '被动反馈']}>
  <Tab value="显式反馈">
    **定义**：用户主动提供的明确评价
    
    ```typescript
    interface ExplicitFeedback {
      // 二元反馈
      thumbsUp?: boolean;
      thumbsDown?: boolean;
      
      // 评分反馈
      rating?: number;  // 1-5 星
      
      // 文本反馈
      comment?: string;
      
      // 问题报告
      issueType?: 'bug' | 'quality' | 'feature' | 'other';
      
      // 标签选择
      tags?: string[];  // ['helpful', 'accurate', 'clear']
    }
    ```
    
    **优点**：
    - 意图明确
    - 易于量化
    - 直接可用
    
    **缺点**：
    - 参与率低
    - 可能有偏
    - 成本较高
  </Tab>
  
  <Tab value="隐式反馈">
    **定义**：从用户行为中推断的反馈
    
    ```typescript
    interface ImplicitFeedback {
      // 交互行为
      copyText: boolean;          // 复制回答
      regenerateResponse: boolean; // 重新生成
      editPrompt: boolean;        // 修改提问
      
      // 时间指标
      readingTime: number;        // 阅读时长
      sessionDuration: number;    // 会话时长
      
      // 深度指标
      followUpQuestions: number;  // 追问次数
      shareAction: boolean;       // 分享行为
      
      // 结果使用
      actionTaken: boolean;       // 采纳建议
      taskCompleted: boolean;     // 任务完成
    }
    ```
    
    **优点**：
    - 数据量大
    - 无需打扰用户
    - 反映真实行为
    
    **缺点**：
    - 解释困难
    - 噪音较多
    - 需要推断
  </Tab>
  
  <Tab value="主动反馈">
    **定义**：系统主动询问用户的反馈
    
    ```python
    class ProactiveFeedback:
        """主动反馈收集"""
        
        def trigger_feedback_request(self, context):
            """触发反馈请求的条件"""
            
            triggers = {
                # 关键时刻
                'task_completed': context.task_status == 'done',
                'long_interaction': context.interaction_time > 300,
                'multiple_turns': context.turn_count > 5,
                
                # 质量信号
                'low_confidence': context.model_confidence < 0.7,
                'regenerated': context.regeneration_count > 0,
                
                # 采样策略
                'random_sample': random.random() < 0.1
            }
            
            return any(triggers.values())
    ```
    
    **最佳时机**：
    - 任务完成后
    - 会话结束时
    - 使用高峰后
  </Tab>
  
  <Tab value="被动反馈">
    **定义**：用户自发提供的反馈
    
    ```python
    class PassiveFeedback:
        """被动反馈接收"""
        
        channels = {
            'in_app': {
                'feedback_button': True,
                'help_menu': True,
                'context_menu': True
            },
            'external': {
                'email': 'feedback@company.com',
                'forum': 'community.company.com',
                'social': '@company_support'
            }
        }
        
        def make_feedback_accessible(self):
            """确保反馈渠道易于访问"""
            return {
                'visibility': 'always_visible',
                'steps_required': 1,  # 一键反馈
                'response_time': '<24h'
            }
    ```
  </Tab>
</Tabs>

## 反馈收集实现

### 前端反馈组件

```jsx
// FeedbackWidget.jsx
import React, { useState } from 'react';
import { Star, ThumbsUp, ThumbsDown, MessageSquare } from 'lucide-react';

const FeedbackWidget = ({ sessionId, messageId }) => {
  const [feedbackState, setFeedbackState] = useState({
    rating: null,
    thumb: null,
    showComment: false,
    comment: '',
    tags: []
  });

  const [isSubmitting, setIsSubmitting] = useState(false);

  // 快速反馈 - 点赞/点踩
  const handleThumbFeedback = async (isPositive) => {
    setFeedbackState(prev => ({
      ...prev,
      thumb: isPositive
    }));

    // 立即发送反馈
    await sendFeedback({
      type: 'thumb',
      value: isPositive,
      sessionId,
      messageId,
      timestamp: new Date().toISOString()
    });

    // 如果是负面反馈，展开详细反馈表单
    if (!isPositive) {
      setFeedbackState(prev => ({
        ...prev,
        showComment: true
      }));
    }
  };

  // 星级评分
  const handleRating = async (rating) => {
    setFeedbackState(prev => ({
      ...prev,
      rating
    }));

    await sendFeedback({
      type: 'rating',
      value: rating,
      sessionId,
      messageId
    });

    // 低分展开详细反馈
    if (rating <= 2) {
      setFeedbackState(prev => ({
        ...prev,
        showComment: true
      }));
    }
  };

  // 标签选择
  const handleTagSelect = (tag) => {
    setFeedbackState(prev => ({
      ...prev,
      tags: prev.tags.includes(tag)
        ? prev.tags.filter(t => t !== tag)
        : [...prev.tags, tag]
    }));
  };

  // 提交详细反馈
  const handleSubmitFeedback = async () => {
    setIsSubmitting(true);

    await sendFeedback({
      type: 'detailed',
      rating: feedbackState.rating,
      thumb: feedbackState.thumb,
      comment: feedbackState.comment,
      tags: feedbackState.tags,
      sessionId,
      messageId,
      metadata: {
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString(),
        pageUrl: window.location.href
      }
    });

    setIsSubmitting(false);
    // 显示感谢信息
    showThankYouMessage();
  };

  return (
    <div className="feedback-widget">
      {/* 快速反馈区 */}
      <div className="quick-feedback">
        <span>这个回答有帮助吗？</span>
        <button
          onClick={() => handleThumbFeedback(true)}
          className={feedbackState.thumb === true ? 'active' : ''}
        >
          <ThumbsUp size={16} />
        </button>
        <button
          onClick={() => handleThumbFeedback(false)}
          className={feedbackState.thumb === false ? 'active' : ''}
        >
          <ThumbsDown size={16} />
        </button>
      </div>

      {/* 星级评分 */}
      <div className="rating-feedback">
        {[1, 2, 3, 4, 5].map(star => (
          <Star
            key={star}
            size={20}
            onClick={() => handleRating(star)}
            fill={feedbackState.rating >= star ? '#FFD700' : 'none'}
            style={{ cursor: 'pointer' }}
          />
        ))}
      </div>

      {/* 详细反馈表单 */}
      {feedbackState.showComment && (
        <div className="detailed-feedback">
          <div className="feedback-tags">
            <p>请选择问题类型（可多选）：</p>
            {['不准确', '不相关', '不完整', '难理解', '太慢'].map(tag => (
              <button
                key={tag}
                onClick={() => handleTagSelect(tag)}
                className={feedbackState.tags.includes(tag) ? 'selected' : ''}
              >
                {tag}
              </button>
            ))}
          </div>

          <textarea
            placeholder="请详细描述您的反馈..."
            value={feedbackState.comment}
            onChange={(e) => setFeedbackState(prev => ({
              ...prev,
              comment: e.target.value
            }))}
            rows={4}
          />

          <button
            onClick={handleSubmitFeedback}
            disabled={isSubmitting}
            className="submit-btn"
          >
            {isSubmitting ? '提交中...' : '提交反馈'}
          </button>
        </div>
      )}
    </div>
  );
};

// 发送反馈到后端
async function sendFeedback(feedback) {
  try {
    const response = await fetch('/api/feedback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(feedback)
    });

    // 记录到分析系统
    if (window.analytics) {
      window.analytics.track('Feedback Submitted', feedback);
    }

    return response.json();
  } catch (error) {
    console.error('Failed to send feedback:', error);
    // 失败时存储到本地，稍后重试
    storeFeedbackLocally(feedback);
  }
}

export default FeedbackWidget;
```

### 后端反馈处理

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List, Dict
import asyncio
from collections import defaultdict

app = FastAPI()

class FeedbackProcessor:
    """反馈处理系统"""
    
    def __init__(self):
        self.feedback_queue = asyncio.Queue()
        self.feedback_store = []
        self.analytics = FeedbackAnalytics()
        self.alert_system = AlertSystem()
    
    async def process_feedback(self, feedback: Dict):
        """处理反馈"""
        
        # 1. 数据验证和清洗
        cleaned_feedback = self.clean_feedback(feedback)
        
        # 2. 实时分析
        analysis = await self.analytics.analyze_realtime(cleaned_feedback)
        
        # 3. 触发告警（如果需要）
        if analysis['severity'] == 'critical':
            await self.alert_system.trigger_alert(cleaned_feedback, analysis)
        
        # 4. 存储反馈
        await self.store_feedback(cleaned_feedback, analysis)
        
        # 5. 更新指标
        await self.update_metrics(cleaned_feedback)
        
        # 6. 触发改进流程
        if analysis['requires_action']:
            await self.trigger_improvement_workflow(cleaned_feedback, analysis)
        
        return {
            'status': 'processed',
            'feedback_id': cleaned_feedback['id'],
            'analysis': analysis
        }
    
    def clean_feedback(self, feedback: Dict) -> Dict:
        """清洗和标准化反馈数据"""
        
        # 添加元数据
        feedback['id'] = str(uuid.uuid4())
        feedback['processed_at'] = datetime.now().isoformat()
        
        # 标准化评分
        if 'rating' in feedback:
            feedback['normalized_score'] = feedback['rating'] / 5.0
        elif 'thumb' in feedback:
            feedback['normalized_score'] = 1.0 if feedback['thumb'] else 0.0
        
        # 情感分析（如果有文本）
        if 'comment' in feedback and feedback['comment']:
            feedback['sentiment'] = self.analyze_sentiment(feedback['comment'])
        
        return feedback
    
    async def store_feedback(self, feedback: Dict, analysis: Dict):
        """存储反馈数据"""
        
        # 存储到数据库
        await self.db.feedback.insert_one({
            **feedback,
            'analysis': analysis
        })
        
        # 存储到数据湖（用于批量分析）
        await self.data_lake.append('feedback', feedback)
        
        # 更新缓存
        self.cache.set(f"feedback:{feedback['id']}", feedback, ttl=3600)

class FeedbackAnalytics:
    """反馈分析系统"""
    
    def __init__(self):
        self.sentiment_analyzer = SentimentAnalyzer()
        self.issue_detector = IssueDetector()
        self.trend_analyzer = TrendAnalyzer()
    
    async def analyze_realtime(self, feedback: Dict) -> Dict:
        """实时分析单条反馈"""
        
        analysis = {
            'severity': self.calculate_severity(feedback),
            'category': self.categorize_feedback(feedback),
            'requires_action': False,
            'insights': []
        }
        
        # 检测关键问题
        if feedback.get('normalized_score', 1) < 0.4:
            analysis['requires_action'] = True
            analysis['insights'].append('Low satisfaction detected')
        
        # 分析文本反馈
        if 'comment' in feedback:
            issues = await self.issue_detector.detect(feedback['comment'])
            if issues:
                analysis['issues'] = issues
                analysis['requires_action'] = True
        
        # 检测趋势
        trend = await self.trend_analyzer.check_trend(feedback)
        if trend['is_anomaly']:
            analysis['trend_alert'] = trend
            analysis['requires_action'] = True
        
        return analysis
    
    def calculate_severity(self, feedback: Dict) -> str:
        """计算问题严重程度"""
        
        score = feedback.get('normalized_score', 0.5)
        
        if score < 0.2:
            return 'critical'
        elif score < 0.4:
            return 'high'
        elif score < 0.6:
            return 'medium'
        else:
            return 'low'
    
    async def batch_analysis(self, timeframe: str = '24h') -> Dict:
        """批量分析反馈数据"""
        
        feedbacks = await self.get_feedbacks_by_timeframe(timeframe)
        
        analysis = {
            'total_count': len(feedbacks),
            'average_score': self.calculate_average_score(feedbacks),
            'sentiment_distribution': self.calculate_sentiment_distribution(feedbacks),
            'top_issues': self.identify_top_issues(feedbacks),
            'user_segments': self.segment_users(feedbacks),
            'recommendations': self.generate_recommendations(feedbacks)
        }
        
        return analysis

class FeedbackAggregator:
    """反馈聚合器"""
    
    def __init__(self):
        self.aggregations = defaultdict(list)
    
    def aggregate_by_session(self, feedbacks: List[Dict]) -> Dict:
        """按会话聚合反馈"""
        
        sessions = defaultdict(list)
        for feedback in feedbacks:
            sessions[feedback['session_id']].append(feedback)
        
        session_scores = {}
        for session_id, session_feedbacks in sessions.items():
            scores = [f.get('normalized_score', 0) for f in session_feedbacks]
            session_scores[session_id] = {
                'average_score': np.mean(scores),
                'min_score': np.min(scores),
                'max_score': np.max(scores),
                'feedback_count': len(session_feedbacks),
                'has_negative': any(s < 0.4 for s in scores)
            }
        
        return session_scores
    
    def aggregate_by_feature(self, feedbacks: List[Dict]) -> Dict:
        """按功能特性聚合反馈"""
        
        features = defaultdict(lambda: {'scores': [], 'comments': []})
        
        for feedback in feedbacks:
            feature = self.identify_feature(feedback)
            if 'normalized_score' in feedback:
                features[feature]['scores'].append(feedback['normalized_score'])
            if 'comment' in feedback:
                features[feature]['comments'].append(feedback['comment'])
        
        feature_analysis = {}
        for feature, data in features.items():
            feature_analysis[feature] = {
                'average_score': np.mean(data['scores']) if data['scores'] else None,
                'feedback_count': len(data['scores']),
                'common_issues': self.extract_common_issues(data['comments'])
            }
        
        return feature_analysis
```

### 反馈数据分析

```python
class FeedbackInsights:
    """反馈洞察生成"""
    
    def generate_insights(self, feedback_data: List[Dict]) -> Dict:
        """生成反馈洞察报告"""
        
        insights = {
            'summary': self.generate_summary(feedback_data),
            'trends': self.analyze_trends(feedback_data),
            'correlations': self.find_correlations(feedback_data),
            'segments': self.analyze_segments(feedback_data),
            'actionable_items': self.extract_actionable_items(feedback_data)
        }
        
        return insights
    
    def analyze_trends(self, feedback_data: List[Dict]) -> Dict:
        """趋势分析"""
        
        # 时间序列分析
        time_series = self.create_time_series(feedback_data)
        
        trends = {
            'satisfaction_trend': self.calculate_trend(time_series['scores']),
            'volume_trend': self.calculate_trend(time_series['counts']),
            'issue_evolution': self.track_issue_evolution(feedback_data),
            'sentiment_shift': self.analyze_sentiment_shift(feedback_data)
        }
        
        # 预测未来趋势
        trends['forecast'] = self.forecast_satisfaction(time_series)
        
        return trends
    
    def find_correlations(self, feedback_data: List[Dict]) -> Dict:
        """相关性分析"""
        
        correlations = {}
        
        # 用户行为与满意度的相关性
        behavior_satisfaction = self.correlate_behavior_satisfaction(feedback_data)
        correlations['behavior_impact'] = behavior_satisfaction
        
        # 响应时间与满意度的相关性
        latency_satisfaction = self.correlate_latency_satisfaction(feedback_data)
        correlations['latency_impact'] = latency_satisfaction
        
        # 功能使用与满意度的相关性
        feature_satisfaction = self.correlate_feature_satisfaction(feedback_data)
        correlations['feature_impact'] = feature_satisfaction
        
        return correlations
    
    def extract_actionable_items(self, feedback_data: List[Dict]) -> List[Dict]:
        """提取可执行的改进项"""
        
        actionable_items = []
        
        # 分析负面反馈
        negative_feedback = [f for f in feedback_data if f.get('normalized_score', 1) < 0.4]
        
        # 聚类相似问题
        issue_clusters = self.cluster_issues(negative_feedback)
        
        for cluster in issue_clusters:
            actionable_items.append({
                'priority': self.calculate_priority(cluster),
                'issue': cluster['common_issue'],
                'affected_users': cluster['user_count'],
                'suggested_action': self.suggest_action(cluster),
                'expected_impact': self.estimate_impact(cluster)
            })
        
        # 按优先级排序
        actionable_items.sort(key=lambda x: x['priority'], reverse=True)
        
        return actionable_items
```

## 反馈驱动的改进流程

### 自动化改进循环

```python
class FeedbackDrivenImprovement:
    """反馈驱动的自动改进系统"""
    
    def __init__(self):
        self.improvement_queue = asyncio.Queue()
        self.model_updater = ModelUpdater()
        self.prompt_optimizer = PromptOptimizer()
    
    async def improvement_pipeline(self, feedback_batch: List[Dict]):
        """改进流水线"""
        
        # 1. 识别改进机会
        opportunities = await self.identify_opportunities(feedback_batch)
        
        # 2. 生成改进方案
        improvements = []
        for opportunity in opportunities:
            improvement = await self.generate_improvement(opportunity)
            improvements.append(improvement)
        
        # 3. 验证改进方案
        validated_improvements = await self.validate_improvements(improvements)
        
        # 4. 实施改进
        results = []
        for improvement in validated_improvements:
            result = await self.implement_improvement(improvement)
            results.append(result)
        
        # 5. A/B 测试
        await self.run_ab_tests(results)
        
        return results
    
    async def identify_opportunities(self, feedback_batch: List[Dict]) -> List[Dict]:
        """识别改进机会"""
        
        opportunities = []
        
        # 分析常见问题
        common_issues = self.extract_common_issues(feedback_batch)
        
        for issue in common_issues:
            if issue['frequency'] > 10 and issue['avg_score'] < 0.5:
                opportunities.append({
                    'type': 'quality_issue',
                    'description': issue['description'],
                    'examples': issue['examples'],
                    'impact': issue['frequency'] * (1 - issue['avg_score'])
                })
        
        # 分析性能问题
        performance_issues = self.analyze_performance_feedback(feedback_batch)
        for issue in performance_issues:
            opportunities.append({
                'type': 'performance_issue',
                'metric': issue['metric'],
                'current_value': issue['current'],
                'target_value': issue['target']
            })
        
        return opportunities
    
    async def generate_improvement(self, opportunity: Dict) -> Dict:
        """生成改进方案"""
        
        improvement = {
            'opportunity': opportunity,
            'solutions': []
        }
        
        if opportunity['type'] == 'quality_issue':
            # 生成 Prompt 优化方案
            prompt_improvements = await self.prompt_optimizer.optimize(
                opportunity['examples']
            )
            improvement['solutions'].extend(prompt_improvements)
            
            # 生成模型微调方案
            if opportunity['impact'] > 100:
                finetune_plan = await self.model_updater.plan_finetune(
                    opportunity['examples']
                )
                improvement['solutions'].append(finetune_plan)
        
        elif opportunity['type'] == 'performance_issue':
            # 生成性能优化方案
            perf_improvements = await self.generate_performance_improvements(
                opportunity
            )
            improvement['solutions'].extend(perf_improvements)
        
        return improvement
```

### A/B 测试框架

```python
class FeedbackABTesting:
    """基于反馈的 A/B 测试"""
    
    def __init__(self):
        self.experiments = {}
        self.results = {}
    
    def create_experiment(self, name: str, variants: List[Dict]) -> str:
        """创建 A/B 测试实验"""
        
        experiment_id = str(uuid.uuid4())
        
        self.experiments[experiment_id] = {
            'name': name,
            'variants': variants,
            'start_time': datetime.now(),
            'status': 'running',
            'allocation': self.calculate_allocation(variants),
            'metrics': {
                'primary': 'user_satisfaction',
                'secondary': ['task_completion', 'response_time']
            }
        }
        
        return experiment_id
    
    def assign_variant(self, experiment_id: str, user_id: str) -> str:
        """分配实验变体"""
        
        experiment = self.experiments[experiment_id]
        
        # 使用一致性哈希确保同一用户总是看到同一变体
        hash_value = hashlib.md5(f"{experiment_id}:{user_id}".encode()).hexdigest()
        hash_int = int(hash_value, 16)
        
        # 根据分配比例选择变体
        cumulative = 0
        for variant in experiment['variants']:
            cumulative += experiment['allocation'][variant['id']]
            if hash_int % 100 < cumulative:
                return variant['id']
        
        return experiment['variants'][0]['id']  # 默认返回第一个变体
    
    def collect_feedback(self, experiment_id: str, variant_id: str, 
                        feedback: Dict):
        """收集实验反馈"""
        
        if experiment_id not in self.results:
            self.results[experiment_id] = defaultdict(list)
        
        self.results[experiment_id][variant_id].append({
            'feedback': feedback,
            'timestamp': datetime.now()
        })
        
        # 检查是否达到统计显著性
        if self.check_significance(experiment_id):
            self.conclude_experiment(experiment_id)
    
    def check_significance(self, experiment_id: str) -> bool:
        """检查统计显著性"""
        
        results = self.results.get(experiment_id, {})
        
        if len(results) < 2:
            return False
        
        # 获取各变体的样本
        samples = {}
        for variant_id, feedbacks in results.items():
            scores = [f['feedback'].get('normalized_score', 0) for f in feedbacks]
            samples[variant_id] = scores
        
        # 样本量检查
        min_samples = 100
        if any(len(s) < min_samples for s in samples.values()):
            return False
        
        # 进行统计检验（t-test）
        from scipy import stats
        
        variants = list(samples.keys())
        if len(variants) == 2:
            t_stat, p_value = stats.ttest_ind(
                samples[variants[0]], 
                samples[variants[1]]
            )
            
            # p < 0.05 表示统计显著
            return p_value < 0.05
        
        # 多变体使用 ANOVA
        f_stat, p_value = stats.f_oneway(*samples.values())
        return p_value < 0.05
    
    def conclude_experiment(self, experiment_id: str) -> Dict:
        """结束实验并得出结论"""
        
        experiment = self.experiments[experiment_id]
        results = self.results[experiment_id]
        
        # 计算各变体的指标
        variant_metrics = {}
        for variant_id, feedbacks in results.items():
            scores = [f['feedback'].get('normalized_score', 0) for f in feedbacks]
            variant_metrics[variant_id] = {
                'mean_score': np.mean(scores),
                'std_score': np.std(scores),
                'sample_size': len(scores),
                'confidence_interval': self.calculate_ci(scores)
            }
        
        # 确定获胜变体
        winner = max(variant_metrics.items(), key=lambda x: x[1]['mean_score'])
        
        conclusion = {
            'experiment_id': experiment_id,
            'winner': winner[0],
            'metrics': variant_metrics,
            'improvement': self.calculate_improvement(variant_metrics),
            'recommendation': self.generate_recommendation(winner, variant_metrics)
        }
        
        experiment['status'] = 'completed'
        experiment['conclusion'] = conclusion
        
        return conclusion
```

## 反馈可视化

### 实时反馈仪表板

```jsx
// FeedbackDashboard.jsx
import React, { useState, useEffect } from 'react';
import { LineChart, BarChart, PieChart, HeatMap } from 'recharts';

const FeedbackDashboard = () => {
  const [metrics, setMetrics] = useState({});
  const [timeRange, setTimeRange] = useState('24h');
  
  useEffect(() => {
    // 实时更新
    const ws = new WebSocket('ws://localhost:8000/feedback/stream');
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      updateMetrics(update);
    };
    
    return () => ws.close();
  }, []);
  
  return (
    <div className="dashboard">
      {/* 关键指标卡片 */}
      <div className="metrics-grid">
        <MetricCard
          title="用户满意度"
          value={metrics.satisfaction?.current}
          trend={metrics.satisfaction?.trend}
          target={4.5}
        />
        <MetricCard
          title="反馈响应率"
          value={metrics.responseRate}
          format="percentage"
        />
        <MetricCard
          title="平均评分"
          value={metrics.averageRating}
          max={5}
        />
        <MetricCard
          title="问题解决率"
          value={metrics.resolutionRate}
          format="percentage"
        />
      </div>
      
      {/* 趋势图表 */}
      <div className="charts-section">
        <div className="chart-container">
          <h3>满意度趋势</h3>
          <LineChart
            data={metrics.satisfactionTrend}
            xAxis="time"
            yAxis="score"
            showTrendline
          />
        </div>
        
        <div className="chart-container">
          <h3>反馈类型分布</h3>
          <PieChart
            data={metrics.feedbackTypes}
            labelKey="type"
            valueKey="count"
          />
        </div>
        
        <div className="chart-container">
          <h3>问题热力图</h3>
          <HeatMap
            data={metrics.issueHeatmap}
            xAxis="hour"
            yAxis="category"
            intensity="count"
          />
        </div>
      </div>
      
      {/* 实时反馈流 */}
      <div className="feedback-stream">
        <h3>最新反馈</h3>
        <FeedbackList
          feedbacks={metrics.recentFeedbacks}
          onReply={(id) => handleReply(id)}
        />
      </div>
      
      {/* 改进建议 */}
      <div className="recommendations">
        <h3>改进建议</h3>
        <RecommendationList
          items={metrics.recommendations}
          onImplement={(id) => implementRecommendation(id)}
        />
      </div>
    </div>
  );
};
```

## 最佳实践

<Cards>
  <Card title="降低反馈门槛">
    让用户能够一键提供反馈，复杂的表单会大大降低参与率
  </Card>
  
  <Card title="及时响应">
    对用户反馈及时响应和处理，让用户感受到被重视
  </Card>
  
  <Card title="闭环管理">
    告知用户他们的反馈如何被使用，形成正向循环
  </Card>
  
  <Card title="多维度收集">
    结合显式和隐式反馈，获得更全面的用户体验数据
  </Card>
</Cards>

## 隐私和合规

### 反馈数据处理合规性

```python
class FeedbackPrivacyCompliance:
    """反馈数据隐私合规"""
    
    def anonymize_feedback(self, feedback: Dict) -> Dict:
        """匿名化反馈数据"""
        
        # 移除个人识别信息
        pii_fields = ['user_id', 'email', 'ip_address', 'device_id']
        for field in pii_fields:
            if field in feedback:
                feedback[f'{field}_hash'] = self.hash_pii(feedback[field])
                del feedback[field]
        
        # 模糊化位置信息
        if 'location' in feedback:
            feedback['location'] = self.generalize_location(feedback['location'])
        
        # 清理自由文本中的敏感信息
        if 'comment' in feedback:
            feedback['comment'] = self.remove_pii_from_text(feedback['comment'])
        
        return feedback
    
    def get_user_consent(self, user_id: str) -> bool:
        """检查用户同意状态"""
        consent = self.consent_db.get(user_id)
        return consent and consent['feedback_collection'] == True
    
    def handle_deletion_request(self, user_id: str):
        """处理用户数据删除请求（GDPR Article 17）"""
        
        # 删除可识别的反馈数据
        self.feedback_db.delete_many({'user_id': user_id})
        
        # 保留匿名化的聚合数据
        self.audit_log.record('user_data_deleted', user_id)
```

## 关键要点

- ✅ 用户反馈是最真实的评估数据
- ✅ 降低反馈门槛能显著提高参与率
- ✅ 及时响应和闭环管理建立信任
- ✅ 结合多种反馈类型获得全面洞察
- ✅ 自动化分析和改进流程提高效率

## 下一步

<Card title="自定义评分 →" href="/docs/evaluation-methods/custom-scoring" description="学习如何设计针对特定业务需求的评分系统" />