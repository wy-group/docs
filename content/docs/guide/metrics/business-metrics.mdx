---
title: 业务指标
description: 从业务视角评估 LLM 系统的价值和影响，包括用户满意度、转化率、ROI 等
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# 业务指标

业务指标将技术性能转化为商业价值，是评估 LLM 系统实际影响力的关键。本章介绍如何定义、测量和优化业务相关的评估指标。

## 业务指标体系

### 指标框架

<Mermaid
  chart="
graph TD
    A[业务指标] --> B[用户指标]
    A --> C[价值指标]
    A --> D[运营指标]
    A --> E[财务指标]
    
    B --> B1[满意度]
    B --> B2[参与度]
    B --> B3[留存率]
    
    C --> C1[任务完成]
    C --> C2[问题解决]
    C --> C3[价值创造]
    
    D --> D1[效率提升]
    D --> D2[自动化率]
    D --> D3[规模化]
    
    E --> E1[成本节约]
    E --> E2[收入增长]
    E --> E3[ROI]"
/>

## 核心业务指标

### 1. 用户满意度 (User Satisfaction)

<Tabs items={['定义与测量', '实现代码', '分析方法', '改进策略']}>
  <Tab value="定义与测量">
**满意度维度**：
- **整体满意度**：用户对服务的总体评价
- **功能满意度**：对具体功能的满意程度
- **体验满意度**：使用体验的流畅度
- **价值满意度**：感知价值vs期望

**测量方法**：
```python
satisfaction_metrics = {
    'CSAT': 'Customer Satisfaction Score (1-5)',
    'NPS': 'Net Promoter Score (-100 to 100)',
    'CES': 'Customer Effort Score (1-7)',
    'SUS': 'System Usability Scale (0-100)'
}
```

**行业基准**：

| 指标 | 优秀 | 良好 | 需改进 |
|-----|------|------|--------|
| CSAT | \>4.5 | 3.5-4.5 | \<3.5 |
| NPS | \>50 | 0-50 | \<0 |
| CES | \<2 | 2-4 | \>4 |
| SUS | \>80 | 68-80 | \<68 |
  </Tab>
  
  <Tab value="实现代码">
    ```python
    from typing import List, Dict, Optional
    from datetime import datetime, timedelta
    import numpy as np
    
    class UserSatisfactionTracker:
        """用户满意度追踪器"""
        
        def __init__(self):
            self.feedback_data = []
            self.response_cache = {}
        
        def collect_csat(self, user_id: str, session_id: str, rating: int, 
                         comment: Optional[str] = None):
            """收集CSAT评分"""
            
            feedback = {
                'type': 'CSAT',
                'user_id': user_id,
                'session_id': session_id,
                'rating': rating,  # 1-5
                'comment': comment,
                'timestamp': datetime.now(),
                'metadata': self.get_session_metadata(session_id)
            }
            
            self.feedback_data.append(feedback)
            
            # 实时分析
            if rating <= 2:
                self.trigger_low_satisfaction_alert(feedback)
            
            return feedback
        
        def calculate_nps(self, time_window: timedelta = timedelta(days=30)) -> Dict:
            """计算NPS分数"""
            
            cutoff_time = datetime.now() - time_window
            recent_ratings = [
                f for f in self.feedback_data 
                if f['type'] == 'NPS' and f['timestamp'] > cutoff_time
            ]
            
            if not recent_ratings:
                return {'nps': None, 'sample_size': 0}
            
            # 分类用户
            promoters = sum(1 for r in recent_ratings if r['rating'] >= 9)
            detractors = sum(1 for r in recent_ratings if r['rating'] <= 6)
            passives = len(recent_ratings) - promoters - detractors
            
            total = len(recent_ratings)
            nps = ((promoters - detractors) / total) * 100
            
            return {
                'nps': nps,
                'promoters': promoters,
                'passives': passives,
                'detractors': detractors,
                'sample_size': total,
                'breakdown': {
                    'promoter_rate': promoters / total,
                    'passive_rate': passives / total,
                    'detractor_rate': detractors / total
                },
                'trend': self.calculate_nps_trend()
            }
        
        def calculate_ces(self, task_id: str) -> float:
            """计算客户努力分数"""
            
            task_feedback = [
                f for f in self.feedback_data 
                if f.get('task_id') == task_id and f['type'] == 'CES'
            ]
            
            if not task_feedback:
                return None
            
            # CES: 1(非常容易) - 7(非常困难)
            efforts = [f['effort_score'] for f in task_feedback]
            avg_effort = np.mean(efforts)
            
            # 分析努力点
            effort_analysis = self.analyze_effort_points(task_feedback)
            
            return {
                'ces': avg_effort,
                'interpretation': self.interpret_ces(avg_effort),
                'sample_size': len(efforts),
                'effort_points': effort_analysis,
                'improvement_suggestions': self.generate_ces_improvements(effort_analysis)
            }
        
        def track_satisfaction_drivers(self) -> Dict:
            """追踪满意度驱动因素"""
            
            # 相关性分析
            correlations = {}
            
            # 响应时间 vs 满意度
            correlations['response_time'] = self.correlate_with_satisfaction('response_time')
            
            # 准确性 vs 满意度
            correlations['accuracy'] = self.correlate_with_satisfaction('accuracy_score')
            
            # 完整性 vs 满意度
            correlations['completeness'] = self.correlate_with_satisfaction('completeness_score')
            
            # 识别关键驱动因素
            key_drivers = sorted(
                correlations.items(), 
                key=lambda x: abs(x[1]), 
                reverse=True
            )[:5]
            
            return {
                'correlations': correlations,
                'key_drivers': key_drivers,
                'recommendations': self.generate_driver_recommendations(key_drivers)
            }
        
        def segment_satisfaction(self) -> Dict:
            """用户满意度分群"""
            
            segments = {
                'highly_satisfied': [],
                'satisfied': [],
                'neutral': [],
                'dissatisfied': [],
                'highly_dissatisfied': []
            }
            
            for feedback in self.feedback_data:
                if feedback['type'] != 'CSAT':
                    continue
                
                rating = feedback['rating']
                user_profile = self.get_user_profile(feedback['user_id'])
                
                segment_data = {
                    'user_id': feedback['user_id'],
                    'rating': rating,
                    'profile': user_profile,
                    'behavior': self.get_user_behavior(feedback['user_id'])
                }
                
                if rating >= 4.5:
                    segments['highly_satisfied'].append(segment_data)
                elif rating >= 3.5:
                    segments['satisfied'].append(segment_data)
                elif rating >= 2.5:
                    segments['neutral'].append(segment_data)
                elif rating >= 1.5:
                    segments['dissatisfied'].append(segment_data)
                else:
                    segments['highly_dissatisfied'].append(segment_data)
            
            # 分析每个分群的特征
            segment_analysis = {}
            for segment_name, users in segments.items():
                if users:
                    segment_analysis[segment_name] = {
                        'count': len(users),
                        'percentage': len(users) / len(self.feedback_data),
                        'common_traits': self.identify_common_traits(users),
                        'typical_issues': self.identify_typical_issues(users),
                        'retention_rate': self.calculate_segment_retention(users)
                    }
            
            return segment_analysis
    ```
  </Tab>
  
  <Tab value="分析方法">
    ```python
    class SatisfactionAnalyzer:
        """满意度分析器"""
        
        def analyze_satisfaction_trends(self, data: List[Dict]) -> Dict:
            """分析满意度趋势"""
            
            # 时间序列分析
            time_series = self.create_time_series(data)
            
            # 趋势检测
            trend = {
                'direction': self.detect_trend_direction(time_series),
                'strength': self.calculate_trend_strength(time_series),
                'seasonality': self.detect_seasonality(time_series),
                'forecast': self.forecast_satisfaction(time_series)
            }
            
            # 异常检测
            anomalies = self.detect_anomalies(time_series)
            
            # 因果分析
            causal_factors = self.analyze_causal_factors(data)
            
            return {
                'trend': trend,
                'anomalies': anomalies,
                'causal_factors': causal_factors,
                'insights': self.generate_insights(trend, anomalies, causal_factors)
            }
        
        def perform_cohort_analysis(self, users: List[Dict]) -> Dict:
            """队列分析"""
            
            cohorts = {}
            
            # 按注册时间分组
            for user in users:
                cohort_key = user['registration_date'].strftime('%Y-%m')
                if cohort_key not in cohorts:
                    cohorts[cohort_key] = []
                cohorts[cohort_key].append(user)
            
            # 分析每个队列
            cohort_metrics = {}
            for cohort_key, cohort_users in cohorts.items():
                cohort_metrics[cohort_key] = {
                    'size': len(cohort_users),
                    'avg_satisfaction': self.calculate_avg_satisfaction(cohort_users),
                    'retention_curve': self.calculate_retention_curve(cohort_users),
                    'ltv': self.calculate_ltv(cohort_users),
                    'churn_rate': self.calculate_churn_rate(cohort_users)
                }
            
            return {
                'cohorts': cohort_metrics,
                'best_performing': self.identify_best_cohort(cohort_metrics),
                'patterns': self.identify_cohort_patterns(cohort_metrics)
            }
        
        def analyze_feedback_sentiment(self, comments: List[str]) -> Dict:
            """分析反馈情感"""
            
            from textblob import TextBlob
            import nltk
            from wordcloud import WordCloud
            
            sentiments = []
            topics = []
            
            for comment in comments:
                # 情感分析
                blob = TextBlob(comment)
                sentiments.append({
                    'polarity': blob.sentiment.polarity,
                    'subjectivity': blob.sentiment.subjectivity
                })
                
                # 主题提取
                topics.extend(self.extract_topics(comment))
            
            # 生成词云
            wordcloud = WordCloud().generate(' '.join(comments))
            
            return {
                'avg_sentiment': np.mean([s['polarity'] for s in sentiments]),
                'sentiment_distribution': self.categorize_sentiments(sentiments),
                'top_topics': self.get_top_topics(topics),
                'wordcloud': wordcloud,
                'actionable_feedback': self.extract_actionable_feedback(comments)
            }
    ```
  </Tab>
  
  <Tab value="改进策略">
    ```python
    class SatisfactionImprovement:
        """满意度改进策略"""
        
        def generate_improvement_plan(self, current_metrics: Dict) -> Dict:
            """生成改进计划"""
            
            plan = {
                'priority_areas': [],
                'quick_wins': [],
                'long_term_initiatives': [],
                'expected_impact': {}
            }
            
            # 识别优先改进领域
            if current_metrics['nps'] < 0:
                plan['priority_areas'].append({
                    'area': 'detractor_reduction',
                    'current': current_metrics['detractor_rate'],
                    'target': 0.15,
                    'actions': [
                        'Implement proactive support for at-risk users',
                        'Create detractor recovery program',
                        'Enhance issue resolution speed'
                    ]
                })
            
            # 快速改进项
            if current_metrics['ces'] > 4:
                plan['quick_wins'].append({
                    'initiative': 'simplify_user_flow',
                    'effort': 'low',
                    'impact': 'high',
                    'timeline': '2 weeks',
                    'actions': [
                        'Reduce steps in common tasks',
                        'Add inline help',
                        'Improve error messages'
                    ]
                })
            
            # 长期计划
            plan['long_term_initiatives'] = [
                {
                    'initiative': 'personalization',
                    'description': 'Implement AI-driven personalization',
                    'timeline': '3-6 months',
                    'expected_nps_lift': 15
                },
                {
                    'initiative': 'proactive_support',
                    'description': 'Build predictive support system',
                    'timeline': '6-9 months',
                    'expected_csat_lift': 0.5
                }
            ]
            
            return plan
        
        def implement_feedback_loop(self):
            """实施反馈循环"""
            
            return {
                'collection': {
                    'channels': ['in-app', 'email', 'chat'],
                    'frequency': 'after_key_interactions',
                    'sampling_rate': 0.2
                },
                'analysis': {
                    'real_time': True,
                    'batch_frequency': 'daily',
                    'alert_thresholds': {
                        'csat': 3.0,
                        'nps': -10
                    }
                },
                'action': {
                    'auto_escalation': True,
                    'response_sla': '24h',
                    'close_loop': True
                }
            }
    ```
  </Tab>
</Tabs>

### 2. 任务完成率 (Task Completion Rate)

```python
class TaskCompletionMetrics:
    """任务完成率指标"""
    
    def __init__(self):
        self.task_registry = {}
        self.completion_data = []
    
    def track_task(self, task_id: str, user_id: str, task_type: str):
        """追踪任务"""
        
        task = {
            'id': task_id,
            'user_id': user_id,
            'type': task_type,
            'start_time': datetime.now(),
            'steps': [],
            'status': 'started',
            'context': self.capture_context()
        }
        
        self.task_registry[task_id] = task
        return task_id
    
    def update_task_progress(self, task_id: str, step: str, success: bool):
        """更新任务进度"""
        
        if task_id not in self.task_registry:
            return
        
        task = self.task_registry[task_id]
        task['steps'].append({
            'name': step,
            'success': success,
            'timestamp': datetime.now()
        })
        
        # 检查是否需要干预
        if not success:
            self.check_intervention_needed(task)
    
    def complete_task(self, task_id: str, success: bool, 
                     outcome: Optional[Dict] = None):
        """完成任务"""
        
        if task_id not in self.task_registry:
            return
        
        task = self.task_registry[task_id]
        task['end_time'] = datetime.now()
        task['duration'] = (task['end_time'] - task['start_time']).total_seconds()
        task['status'] = 'completed' if success else 'failed'
        task['outcome'] = outcome
        
        # 计算任务指标
        task['metrics'] = {
            'completion_rate': self.calculate_step_completion_rate(task),
            'efficiency': self.calculate_task_efficiency(task),
            'friction_points': self.identify_friction_points(task)
        }
        
        self.completion_data.append(task)
        del self.task_registry[task_id]
        
        return task['metrics']
    
    def calculate_overall_completion_rate(self, time_window: Optional[timedelta] = None) -> Dict:
        """计算整体完成率"""
        
        if time_window:
            cutoff = datetime.now() - time_window
            relevant_tasks = [t for t in self.completion_data if t['start_time'] > cutoff]
        else:
            relevant_tasks = self.completion_data
        
        if not relevant_tasks:
            return {'completion_rate': 0, 'sample_size': 0}
        
        completed = sum(1 for t in relevant_tasks if t['status'] == 'completed')
        total = len(relevant_tasks)
        
        # 按任务类型分析
        by_type = {}
        for task_type in set(t['type'] for t in relevant_tasks):
            type_tasks = [t for t in relevant_tasks if t['type'] == task_type]
            type_completed = sum(1 for t in type_tasks if t['status'] == 'completed')
            
            by_type[task_type] = {
                'completion_rate': type_completed / len(type_tasks),
                'avg_duration': np.mean([t['duration'] for t in type_tasks]),
                'common_failures': self.analyze_failure_patterns(type_tasks)
            }
        
        return {
            'overall_completion_rate': completed / total,
            'by_type': by_type,
            'trend': self.calculate_completion_trend(),
            'bottlenecks': self.identify_bottlenecks(relevant_tasks),
            'sample_size': total
        }
    
    def analyze_task_funnel(self, task_type: str) -> Dict:
        """分析任务漏斗"""
        
        type_tasks = [t for t in self.completion_data if t['type'] == task_type]
        
        if not type_tasks:
            return {}
        
        # 构建步骤漏斗
        all_steps = set()
        for task in type_tasks:
            all_steps.update(s['name'] for s in task['steps'])
        
        funnel = {}
        for step in all_steps:
            reached = sum(1 for t in type_tasks if any(s['name'] == step for s in t['steps']))
            completed = sum(1 for t in type_tasks if any(s['name'] == step and s['success'] for s in t['steps']))
            
            funnel[step] = {
                'reached': reached,
                'completed': completed,
                'conversion_rate': completed / reached if reached > 0 else 0
            }
        
        # 识别最大流失点
        sorted_steps = sorted(funnel.items(), key=lambda x: x[1]['conversion_rate'])
        
        return {
            'funnel': funnel,
            'biggest_drop_offs': sorted_steps[:3],
            'optimization_opportunities': self.suggest_funnel_optimizations(funnel)
        }
```

### 3. 用户留存率 (User Retention)

```python
class RetentionMetrics:
    """用户留存指标"""
    
    def calculate_retention_curve(self, cohort_data: List[Dict]) -> Dict:
        """计算留存曲线"""
        
        retention_curve = {}
        cohort_size = len(cohort_data)
        
        # 计算各时间点的留存
        for day in [1, 3, 7, 14, 30, 60, 90]:
            retained = sum(
                1 for user in cohort_data 
                if self.is_active_after_days(user, day)
            )
            retention_curve[f'day_{day}'] = retained / cohort_size if cohort_size > 0 else 0
        
        # 计算关键指标
        metrics = {
            'retention_curve': retention_curve,
            'd1_retention': retention_curve.get('day_1', 0),
            'd7_retention': retention_curve.get('day_7', 0),
            'd30_retention': retention_curve.get('day_30', 0),
            'retention_quality': self.assess_retention_quality(retention_curve),
            'predicted_ltv': self.predict_ltv_from_retention(retention_curve)
        }
        
        return metrics
    
    def analyze_churn(self, user_data: List[Dict]) -> Dict:
        """流失分析"""
        
        churned_users = [u for u in user_data if u['churned']]
        active_users = [u for u in user_data if not u['churned']]
        
        # 流失原因分析
        churn_reasons = self.categorize_churn_reasons(churned_users)
        
        # 流失预测模型
        churn_predictors = self.identify_churn_predictors(user_data)
        
        # 流失时间分布
        churn_timing = self.analyze_churn_timing(churned_users)
        
        return {
            'churn_rate': len(churned_users) / len(user_data),
            'reasons': churn_reasons,
            'predictors': churn_predictors,
            'timing': churn_timing,
            'at_risk_users': self.identify_at_risk_users(active_users, churn_predictors),
            'prevention_strategies': self.generate_churn_prevention_strategies(churn_reasons)
        }
```

### 4. 转化率 (Conversion Rate)

```python
class ConversionMetrics:
    """转化率指标"""
    
    def track_conversion_funnel(self, funnel_steps: List[str]) -> Dict:
        """追踪转化漏斗"""
        
        funnel_data = {}
        
        for i, step in enumerate(funnel_steps):
            if i == 0:
                # 第一步是100%
                funnel_data[step] = {
                    'users': 1000,  # 示例数据
                    'conversion_rate': 1.0
                }
            else:
                prev_step = funnel_steps[i-1]
                prev_users = funnel_data[prev_step]['users']
                
                # 计算转化
                converted = self.get_converted_users(prev_step, step)
                conversion_rate = converted / prev_users if prev_users > 0 else 0
                
                funnel_data[step] = {
                    'users': converted,
                    'conversion_rate': conversion_rate,
                    'drop_off_rate': 1 - conversion_rate
                }
        
        # 计算总体转化率
        overall_conversion = funnel_data[funnel_steps[-1]]['users'] / funnel_data[funnel_steps[0]]['users']
        
        return {
            'funnel': funnel_data,
            'overall_conversion': overall_conversion,
            'biggest_drop_off': self.identify_biggest_drop_off(funnel_data),
            'optimization_potential': self.calculate_optimization_potential(funnel_data)
        }
    
    def calculate_conversion_value(self, conversions: List[Dict]) -> Dict:
        """计算转化价值"""
        
        total_value = sum(c.get('value', 0) for c in conversions)
        avg_value = total_value / len(conversions) if conversions else 0
        
        # 按来源分析
        by_source = {}
        for source in set(c.get('source') for c in conversions):
            source_conversions = [c for c in conversions if c.get('source') == source]
            by_source[source] = {
                'count': len(source_conversions),
                'total_value': sum(c.get('value', 0) for c in source_conversions),
                'avg_value': np.mean([c.get('value', 0) for c in source_conversions]),
                'conversion_rate': len(source_conversions) / self.get_source_traffic(source)
            }
        
        return {
            'total_value': total_value,
            'average_order_value': avg_value,
            'by_source': by_source,
            'high_value_segments': self.identify_high_value_segments(conversions)
        }
```

### 5. 业务影响指标 (Business Impact)

```python
class BusinessImpactMetrics:
    """业务影响指标"""
    
    def calculate_efficiency_gains(self, before_metrics: Dict, after_metrics: Dict) -> Dict:
        """计算效率提升"""
        
        efficiency_gains = {}
        
        # 时间节省
        time_saved = before_metrics['avg_task_time'] - after_metrics['avg_task_time']
        efficiency_gains['time_reduction'] = {
            'absolute': time_saved,
            'percentage': (time_saved / before_metrics['avg_task_time']) * 100,
            'annual_hours_saved': time_saved * after_metrics['task_volume'] * 365
        }
        
        # 成本节省
        cost_per_hour = 50  # 示例成本
        efficiency_gains['cost_savings'] = {
            'per_task': time_saved * cost_per_hour / 60,
            'annual': efficiency_gains['time_reduction']['annual_hours_saved'] * cost_per_hour
        }
        
        # 产能提升
        efficiency_gains['capacity_increase'] = {
            'tasks_per_day': after_metrics['task_volume'] - before_metrics['task_volume'],
            'percentage': ((after_metrics['task_volume'] / before_metrics['task_volume']) - 1) * 100
        }
        
        return efficiency_gains
    
    def calculate_automation_impact(self, automation_data: Dict) -> Dict:
        """计算自动化影响"""
        
        return {
            'automation_rate': automation_data['automated_tasks'] / automation_data['total_tasks'],
            'human_tasks_reduced': automation_data['total_tasks'] - automation_data['manual_tasks'],
            'quality_impact': {
                'error_reduction': automation_data['error_rate_before'] - automation_data['error_rate_after'],
                'consistency_improvement': automation_data['consistency_score']
            },
            'scalability': {
                'max_throughput': automation_data['max_automated_throughput'],
                'scale_without_hiring': automation_data['max_automated_throughput'] / automation_data['human_capacity']
            }
        }
    
    def calculate_revenue_impact(self, revenue_data: Dict) -> Dict:
        """计算收入影响"""
        
        return {
            'direct_revenue': {
                'new_revenue': revenue_data['new_customer_revenue'],
                'upsell_revenue': revenue_data['upsell_revenue'],
                'total': revenue_data['new_customer_revenue'] + revenue_data['upsell_revenue']
            },
            'indirect_revenue': {
                'retention_value': revenue_data['retained_customers'] * revenue_data['customer_ltv'],
                'referral_value': revenue_data['referrals'] * revenue_data['referral_conversion'] * revenue_data['customer_ltv']
            },
            'revenue_per_user': {
                'arpu': revenue_data['total_revenue'] / revenue_data['active_users'],
                'ltv': self.calculate_ltv(revenue_data)
            }
        }
```

## 业务指标仪表板

```python
class BusinessDashboard:
    """业务指标仪表板"""
    
    def generate_executive_summary(self) -> Dict:
        """生成高管摘要"""
        
        return {
            'key_metrics': {
                'user_satisfaction': {
                    'current': 4.2,
                    'target': 4.5,
                    'trend': '↑',
                    'health': 'yellow'
                },
                'task_completion': {
                    'current': 0.85,
                    'target': 0.90,
                    'trend': '→',
                    'health': 'yellow'
                },
                'retention': {
                    'current': 0.75,
                    'target': 0.80,
                    'trend': '↑',
                    'health': 'green'
                },
                'roi': {
                    'current': 3.2,
                    'target': 3.0,
                    'trend': '↑',
                    'health': 'green'
                }
            },
            'highlights': [
                'User satisfaction improved by 5% MoM',
                'Task completion rate stable at 85%',
                'ROI exceeds target by 7%'
            ],
            'concerns': [
                'Slight decrease in D7 retention',
                'Customer effort score increasing'
            ],
            'recommendations': [
                'Focus on reducing task complexity',
                'Implement proactive user support'
            ]
        }
    
    def create_visualization(self, metrics: Dict):
        """创建可视化"""
        
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
        
        # 创建子图
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('用户满意度趋势', '任务完成漏斗', '留存曲线', 'ROI分析'),
            specs=[[{'type': 'scatter'}, {'type': 'funnel'}],
                   [{'type': 'scatter'}, {'type': 'bar'}]]
        )
        
        # 1. 满意度趋势
        fig.add_trace(
            go.Scatter(
                x=metrics['satisfaction']['dates'],
                y=metrics['satisfaction']['scores'],
                mode='lines+markers',
                name='CSAT'
            ),
            row=1, col=1
        )
        
        # 2. 任务完成漏斗
        fig.add_trace(
            go.Funnel(
                y=metrics['funnel']['steps'],
                x=metrics['funnel']['values'],
                textinfo="value+percent initial"
            ),
            row=1, col=2
        )
        
        # 3. 留存曲线
        fig.add_trace(
            go.Scatter(
                x=metrics['retention']['days'],
                y=metrics['retention']['rates'],
                mode='lines+markers',
                name='Retention'
            ),
            row=2, col=1
        )
        
        # 4. ROI分析
        fig.add_trace(
            go.Bar(
                x=['成本', '收益', '净利润'],
                y=metrics['roi']['values'],
                marker_color=['red', 'green', 'blue']
            ),
            row=2, col=2
        )
        
        fig.update_layout(height=800, showlegend=True, title_text="业务指标仪表板")
        
        return fig
```

## 业务指标预警系统

```python
class BusinessAlertSystem:
    """业务指标预警系统"""
    
    def __init__(self):
        self.alert_rules = self.define_alert_rules()
        self.alert_history = []
    
    def define_alert_rules(self) -> List[Dict]:
        """定义预警规则"""
        
        return [
            {
                'metric': 'user_satisfaction',
                'condition': 'below',
                'threshold': 3.5,
                'severity': 'critical',
                'action': 'immediate_escalation'
            },
            {
                'metric': 'task_completion_rate',
                'condition': 'below',
                'threshold': 0.7,
                'severity': 'high',
                'action': 'notify_product_team'
            },
            {
                'metric': 'd7_retention',
                'condition': 'drop',
                'threshold': 0.1,  # 10% drop
                'severity': 'medium',
                'action': 'analyze_cohort'
            },
            {
                'metric': 'churn_rate',
                'condition': 'above',
                'threshold': 0.05,  # 5% monthly
                'severity': 'high',
                'action': 'retention_campaign'
            }
        ]
    
    def check_alerts(self, current_metrics: Dict):
        """检查预警条件"""
        
        alerts = []
        
        for rule in self.alert_rules:
            metric_value = current_metrics.get(rule['metric'])
            
            if self.evaluate_condition(metric_value, rule['condition'], rule['threshold']):
                alert = {
                    'timestamp': datetime.now(),
                    'metric': rule['metric'],
                    'current_value': metric_value,
                    'threshold': rule['threshold'],
                    'severity': rule['severity'],
                    'message': self.generate_alert_message(rule, metric_value),
                    'recommended_action': rule['action']
                }
                
                alerts.append(alert)
                self.alert_history.append(alert)
                
                # 触发行动
                self.trigger_action(alert)
        
        return alerts
```

## 最佳实践

<Cards>
  <Card title="对齐业务目标">
    确保指标与公司战略目标一致
  </Card>
  
  <Card title="平衡指标">
    同时关注短期和长期指标
  </Card>
  
  <Card title="可操作性">
    选择能够指导行动的指标
  </Card>
  
  <Card title="持续优化">
    定期审查和调整指标体系
  </Card>
</Cards>

## 关键要点

- ✅ 业务指标是连接技术和商业价值的桥梁
- ✅ 用户满意度是最核心的业务指标
- ✅ 任务完成率直接反映产品价值
- ✅ 留存率是长期成功的关键
- ✅ ROI 分析帮助证明投资价值